# windows.yml
#
# Odin GitHub Actions Windows CI workflow.
#
# This defines a Windows CMake build for Odin that runs on push + schedule.
#
# Author: Derek Huang
# Copyright: MIT License
#

name: ci-windows

on:
  # run daily as 0000 UTC scheduled job or when any branch is pushed to
  schedule:
    - cron: "0 0 * * *"
  # run on branch push
  push:
    paths-ignore:
      # sheets + VS solution files don't affect the CMake build so ignore them
      - "sheets/**"
      - "solutions/**"
      # README.md doesn't affect CMake build either
      - README.md
  # run on manual request
  workflow_dispatch:

env:
  # install root for dependencies + Odin test install root
  ODIN_VENDOR_ROOT: C:\odin_vendor
  ODIN_INSTALL_ROOT: C:\odin
  # Boost version + semicolon-separated list of libraries for Boost CMake build
  BOOST_VERSION: 1.89.0
  BOOST_CMAKE_LIBS: algorithm
  # Magic Enum version
  MAGIC_ENUM_VERSION: 0.9.7
  # GoogleTest version
  GTEST_VERSION: 1.14.0
  # Excel 2013 XLL SDK MSI name + download link
  XLLSDK_MSI_LINK: "https://download.microsoft.com/download/d/a/c/\
    dac9c321-279c-4625-b381-bcb044eef7b2/excelxllsdk.msi"

jobs:
  # only one job which is the build job
  build:
    runs-on: ${{ matrix.os }}
    name: ${{ matrix.os }} arch=${{ matrix.arch }} unity=${{ matrix.unity }}
    # strategy matrix
    strategy:
      matrix:
        # note: windows-latest is a moving target
        os: [windows-2022, windows-2025]
        # CMake build arch, i.e. what is passed to CMake's -A option
        # TODO: maybe consider allowing build.bat to accept "Win32" as a choice
        arch: [Win32, x64]
        # whether or not to use unity build
        unity: [off, on]
    # job steps
    steps:
      - name: Checkout
        uses: actions/checkout@v5
        with:
          show-progress: true
      # note: no way to easily show CPU feature flags. you could use __cpuid
      # and __cpuidex directly in a C/C++ program but this is more complication
      - name: CPU Info
        run: systeminfo
      # installs + builds required Boost libraries with CMake. see
      # https://www.boost.org/doc/user-guide/getting-started.html#_individual_modules
      # note: originally we used curl to pull an entire Boost release but the
      # Windows 2022 runners have really slow networks for some reason
      - name: Install Boost
        run: |
          $BOOST_TAG = "boost-${{ env.BOOST_VERSION}}"
          # clone Boost repo to specified tag
          cd ${{ runner.temp }}
          git clone https://github.com/boostorg/boost.git -b $BOOST_TAG --depth 1
          cd boost
          # init boostdep + any other required submodules
          git submodule update --depth 1 -q --init tools\boostdep
          ForEach ($module In "${{ env.BOOST_CMAKE_LIBS }}".Split(";"))
          {
            echo "Initializing Boost module $module"
            git submodule update --depth 1 -q --init libs\$module
            python tools\boostdep\depinst\depinst.py -X test -g "--depth 1" $module
          }
          # build just the required components we need. the entire Boost suite
          # of libraries is huge so we don't want to build everything. in most
          # cases the Boost libraries are header-only so nothing is built
          cmake -S . -B build -A ${{ matrix.arch }} `
            -DBOOST_INCLUDE_LIBRARIES=${{ env.BOOST_CMAKE_LIBS }}
          cmake --build build --config Release -j
          cmake --install build `
            --prefix ${{ env.ODIN_VENDOR_ROOT }} `
            --config Release
      # note: don't need to build examples and tests for this. installs into
      # /usr/local by default which is why we need sudo
      - name: Install Magic Enum
        run: |
          cd ${{ runner.temp }}
          git clone https://github.com/Neargye/magic_enum.git
          cd magic_enum
          git checkout v${{ env.MAGIC_ENUM_VERSION }}
          cmake -S . -B build -A ${{ matrix.arch }} `
            -DMAGIC_ENUM_OPT_BUILD_EXAMPLES=OFF `
            -DMAGIC_ENUM_OPT_BUILD_TESTS=OFF
          cmake --build build --config Release -j
          cmake --install build `
            --prefix ${{ env.ODIN_VENDOR_ROOT }} `
            --config Release
      # note: build from source since we want to avoid NuGet's weird packaging
      - name: Install GoogleTest
        run: |
          cd ${{ runner.temp }}
          git clone https://github.com/google/googletest.git
          cd googletest
          git checkout v${{ env.GTEST_VERSION }}
          # note: gtest_force_shared_crt needed otherwise uses static C runtime
          cmake -S . -B build -A ${{ matrix.arch }} -Dgtest_force_shared_crt=ON
          cmake --build build --config Release -j
          cmake --install build `
            --prefix ${{ env.ODIN_VENDOR_ROOT }} `
            --config Release
      # use msiexec to perform XLL SDK installation through the MSI
      - name: Install Excel 2013 XLL SDK
        run: |
          cd ${{ runner.temp }}
          # download MSI to temp dir (verbose output)
          Invoke-WebRequest ${{ env.XLLSDK_MSI_LINK }} `
            -Verbose `
            -OutFile excelxllsdk.msi
          # create install directory
          mkdir ${{ env.ODIN_VENDOR_ROOT }}\Excel2013XLLSDK
          # use msiexec to install without user interaction and no UI. no
          # restart is needed and we log to a log file in case of errors. see
          # https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/msiexec
          # for more details on using msiexec for MSI install
          msiexec /i excelxllsdk.msi /quiet /qn /norestart `
            /log excelxllsdk.log `
            TARGETDIR=${{ env.ODIN_VENDOR_ROOT }}\Excel2013XLLSDK
          # print log file contents
          Get-Content excelxllsdk.log
      # note: not sure if step-level env can use top-level env variables
      # TODO: this is fixed in the FindXLLSDK.cmake PR
      - name: Build
        run: |
          # ToUpper() can be used on PowerShell strings for upper-casing
          $ODIN_UNITY_BUILD = "${{ matrix.unity }}".ToUpper()
          # include PowerShell helpers
          . .\tools\common.ps1
          # run build command
          # note: need explicit use of .\ here unlike with CMD
          # note: need double quotes to be preserved for CMD script
          # note: ` is the escape character in PowerShell
          .\build -a $(OaPlatformTranslate "${{ matrix.arch }}") -c Release -Ca `
            "`"-DCMAKE_PREFIX_PATH=${{ env.ODIN_VENDOR_ROOT }}`"" `
            "`"-DCMAKE_UNITY_BUILD=$ODIN_UNITY_BUILD`""
      # note: we don't have a nice wrapper script for this yet
      - name: Test
        run: |
          # include PowerShell helpers
          . .\tools\common.ps1
          # note: need double quotes for PowerShell
          ctest --test-dir `
            build_windows_$(OaPlatformTranslate "${{ matrix.arch }}") `
            -C Release "-j$env:NUMBER_OF_PROCESSORS" --output-on-failure
      # install Runtime and Development components separately
      # note: only good as a smoke test
      - name: Install Runtime
        run: |
          # load helper script for OaPlatformTranslate
          . .\tools\common.ps1
          # convert Win32 -> x86 for build directory + install
          cmake --install `
            build_windows_$(OaPlatformTranslate "${{ matrix.arch }}") `
            --prefix "${{ env.ODIN_INSTALL_ROOT }}" `
            --config Release `
            --component Runtime
      - name: Install Development
        run: |
          # same as above but install Development component
          . .\tools\common.ps1
          cmake --install `
            build_windows_$(OaPlatformTranslate "${{ matrix.arch }}") `
            --prefix "${{ env.ODIN_INSTALL_ROOT }}" `
            --config Release `
            --component Development
